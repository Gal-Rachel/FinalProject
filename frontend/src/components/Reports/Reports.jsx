import React, { useState, useEffect, useMemo } from 'react';
import { FaDownload, FaEye, FaCalendar, FaShieldAlt, FaExclamationTriangle, FaGlobe, FaServer, FaHistory, FaSave, FaClock } from 'react-icons/fa';
import './Reports.css';

const Reports = () => {
  const [findings, setFindings] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedReport, setSelectedReport] = useState(null);
  const [reportDate, setReportDate] = useState(new Date().toISOString().split('T')[0]);
  const [savedReports, setSavedReports] = useState([]);
  const [showHistory, setShowHistory] = useState(false);
  const [selectedHistoryReport, setSelectedHistoryReport] = useState(null);
  const [autoSaveStatus, setAutoSaveStatus] = useState('');

  useEffect(() => {
    const fetchFindings = async () => {
      try {
        const response = await fetch('http://localhost:5000/api/findings');
        if (!response.ok) {
          throw new Error('Failed to fetch findings');
        }
        const data = await response.json();
        setFindings(data.findings || []);
        setLoading(false);
      } catch (error) {
        console.error('Error fetching findings:', error);
        setLoading(false);
      }
    };

    fetchFindings();
    loadSavedReports();
    checkAndAutoSave();
  }, []);

  // Check if today's reports need to be auto-generated
  const checkAndAutoSave = () => {
    const today = new Date().toISOString().split('T')[0];
    const saved = localStorage.getItem('savedReports');
    const existingReports = saved ? JSON.parse(saved) : [];
    
    // Check if we already have today's reports
    const todayReports = existingReports.filter(r => r.reportDate === today);
    
    if (todayReports.length === 0) {
      // Auto-generate today's reports
      autoGenerateDailyReports(today);
    } else {
      setAutoSaveStatus('Today\'s reports already generated');
    }
  };

  // Auto-generate daily reports
  const autoGenerateDailyReports = (date) => {
    const reports = [
      {
        id: 'executive',
        title: 'Executive Summary',
        generate: generateExecutiveSummary
      },
      {
        id: 'threat',
        title: 'Threat Intelligence Report',
        generate: generateThreatReport
      },
      {
        id: 'compliance',
        title: 'Compliance Report',
        generate: generateComplianceReport
      }
    ];

    const newReports = reports.map(report => {
      const reportData = report.generate();
      return {
        id: `${date}_${report.id}_${Date.now()}`,
        type: report.id,
        title: report.title,
        generatedDate: new Date().toISOString(),
        reportDate: date,
        data: reportData,
        metrics: {
          totalAlerts: reportMetrics.totalAlerts,
          criticalAlerts: reportMetrics.criticalAlerts,
          uniqueIPs: reportMetrics.uniqueIPs,
          uniqueCountries: reportMetrics.uniqueCountries
        },
        autoGenerated: true
      };
    });

    const existingReports = savedReports.filter(r => r.reportDate !== date);
    const updatedReports = [...newReports, ...existingReports];
    
    setSavedReports(updatedReports);
    localStorage.setItem('savedReports', JSON.stringify(updatedReports));
    setAutoSaveStatus(`Auto-generated ${newReports.length} reports for ${date}`);
    
    // Clear status after 3 seconds
    setTimeout(() => setAutoSaveStatus(''), 3000);
  };

  // Load saved reports from localStorage
  const loadSavedReports = () => {
    try {
      const saved = localStorage.getItem('savedReports');
      if (saved) {
        setSavedReports(JSON.parse(saved));
      }
    } catch (error) {
      console.error('Error loading saved reports:', error);
    }
  };

  // Manual save report to history (for custom dates)
  const saveReportToHistory = (report, reportData) => {
    const newReport = {
      id: `${reportDate}_${report.id}_${Date.now()}`,
      type: report.id,
      title: report.title,
      generatedDate: new Date().toISOString(),
      reportDate: reportDate,
      data: reportData,
      metrics: {
        totalAlerts: reportMetrics.totalAlerts,
        criticalAlerts: reportMetrics.criticalAlerts,
        uniqueIPs: reportMetrics.uniqueIPs,
        uniqueCountries: reportMetrics.uniqueCountries
      },
      autoGenerated: false
    };

    // Remove any existing report for this date and type
    const existingReports = savedReports.filter(r => 
      !(r.reportDate === reportDate && r.type === report.id)
    );
    
    const updatedReports = [newReport, ...existingReports];
    setSavedReports(updatedReports);
    
    try {
      localStorage.setItem('savedReports', JSON.stringify(updatedReports));
    } catch (error) {
      console.error('Error saving report:', error);
    }

    alert(`Report "${report.title}" saved for ${reportDate}!`);
  };

  // Delete saved report
  const deleteSavedReport = (reportId) => {
    const updatedReports = savedReports.filter(r => r.id !== reportId);
    setSavedReports(updatedReports);
    
    try {
      localStorage.setItem('savedReports', JSON.stringify(updatedReports));
    } catch (error) {
      console.error('Error deleting report:', error);
    }
  };

  // Calculate report metrics
  const reportMetrics = useMemo(() => {
    const totalAlerts = findings.length;
    const criticalAlerts = findings.filter(f => f.Severity >= 8).length;
    const highAlerts = findings.filter(f => f.Severity >= 6 && f.Severity < 8).length;
    const mediumAlerts = findings.filter(f => f.Severity >= 4 && f.Severity < 6).length;
    const lowAlerts = findings.filter(f => f.Severity < 4).length;
    
    const uniqueIPs = new Set(findings.map(f => 
      f.Service?.Action?.NetworkConnectionAction?.RemoteIpDetails?.IpAddressV4
    ).filter(Boolean)).size;
    
    const uniqueCountries = new Set(findings.map(f => 
      f.Service?.Action?.NetworkConnectionAction?.RemoteIpDetails?.Country?.CountryName
    ).filter(Boolean)).size;

    const threatTypes = {};
    findings.forEach(finding => {
      const type = finding.Type?.split(':')[0] || 'Other';
      threatTypes[type] = (threatTypes[type] || 0) + 1;
    });

    const topThreats = Object.entries(threatTypes)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 5);

    return {
      totalAlerts,
      criticalAlerts,
      highAlerts,
      mediumAlerts,
      lowAlerts,
      uniqueIPs,
      uniqueCountries,
      topThreats,
      avgSeverity: totalAlerts > 0 ? (findings.reduce((sum, f) => sum + (f.Severity || 0), 0) / totalAlerts).toFixed(1) : 0
    };
  }, [findings]);

  // Generate Executive Summary
  const generateExecutiveSummary = () => {
    const { totalAlerts, criticalAlerts, highAlerts, uniqueIPs, uniqueCountries, avgSeverity } = reportMetrics;
    
    return {
      title: "Security Threat Intelligence Report",
      date: new Date().toLocaleDateString(),
      summary: `This report covers ${totalAlerts} security alerts detected across our infrastructure. 
                ${criticalAlerts} critical and ${highAlerts} high-severity threats were identified, 
                originating from ${uniqueIPs} unique IP addresses across ${uniqueCountries} countries. 
                The average threat severity is ${avgSeverity}/10.`,
      keyFindings: [
        `${criticalAlerts} critical threats requiring immediate attention`,
        `${uniqueIPs} unique threat sources identified`,
        `Threats detected from ${uniqueCountries} different countries`,
        `Average threat severity: ${avgSeverity}/10`
      ],
      recommendations: [
        "Implement enhanced network monitoring for critical assets",
        "Review and update firewall rules based on threat patterns",
        "Consider geo-blocking for high-risk regions",
        "Strengthen authentication mechanisms for sensitive resources"
      ]
    };
  };

  // Generate Detailed Threat Report
  const generateThreatReport = () => {
    const { topThreats, uniqueIPs, uniqueCountries } = reportMetrics;
    
    const geographicThreats = {};
    findings.forEach(finding => {
      const country = finding.Service?.Action?.NetworkConnectionAction?.RemoteIpDetails?.Country?.CountryName || 'Unknown';
      geographicThreats[country] = (geographicThreats[country] || 0) + 1;
    });

    const topCountries = Object.entries(geographicThreats)
      .sort((a, b) => b[1] - a[1])
      .slice(0, 10);

    return {
      title: "Detailed Threat Analysis Report",
      date: new Date().toLocaleDateString(),
      threatBreakdown: topThreats.map(([type, count]) => ({
        type,
        count,
        percentage: ((count / reportMetrics.totalAlerts) * 100).toFixed(1)
      })),
      geographicAnalysis: topCountries.map(([country, count]) => ({
        country,
        count,
        percentage: ((count / reportMetrics.totalAlerts) * 100).toFixed(1)
      })),
      networkAnalysis: {
        uniqueIPs,
        uniqueCountries,
        protocols: findings.reduce((acc, f) => {
          const protocol = f.Service?.Action?.NetworkConnectionAction?.Protocol || 'Unknown';
          acc[protocol] = (acc[protocol] || 0) + 1;
          return acc;
        }, {})
      }
    };
  };

  // Generate Compliance Report
  const generateComplianceReport = () => {
    const complianceMetrics = {
      totalFindings: findings.length,
      findingsBySeverity: {
        critical: findings.filter(f => f.Severity >= 8).length,
        high: findings.filter(f => f.Severity >= 6 && f.Severity < 8).length,
        medium: findings.filter(f => f.Severity >= 4 && f.Severity < 6).length,
        low: findings.filter(f => f.Severity < 4).length
      },
      findingsByType: reportMetrics.topThreats,
      responseTime: "Average response time: 2.5 hours",
      resolutionRate: "95% of critical alerts resolved within SLA",
      complianceScore: "87/100"
    };

    return {
      title: "Security Compliance Report",
      date: new Date().toLocaleDateString(),
      complianceScore: complianceMetrics.complianceScore,
      slaMetrics: {
        responseTime: complianceMetrics.responseTime,
        resolutionRate: complianceMetrics.resolutionRate
      },
      findingsSummary: complianceMetrics.findingsBySeverity,
      recommendations: [
        "Maintain current response time standards",
        "Focus on reducing medium-severity findings",
        "Implement automated response for common threats",
        "Enhance threat intelligence integration"
      ]
    };
  };

  const reports = [
    {
      id: 'executive',
      title: 'Executive Summary',
      description: 'High-level security overview for leadership',
      icon: <FaEye />,
      generate: generateExecutiveSummary
    },
    {
      id: 'threat',
      title: 'Threat Intelligence Report',
      description: 'Detailed analysis of security threats and patterns',
      icon: <FaShieldAlt />,
      generate: generateThreatReport
    },
    {
      id: 'compliance',
      title: 'Compliance Report',
      description: 'Security compliance metrics and SLA performance',
      icon: <FaExclamationTriangle />,
      generate: generateComplianceReport
    }
  ];

  const handleGenerateReport = (report) => {
    const reportData = report.generate();
    setSelectedReport({ ...report, data: reportData });
  };

  const handleDownloadReport = (report) => {
    const reportData = report.generate();
    const content = JSON.stringify(reportData, null, 2);
    const blob = new Blob([content], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${report.title.toLowerCase().replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const handleSaveReport = (report) => {
    const reportData = report.generate();
    saveReportToHistory(report, reportData);
  };

  const formatDate = (dateString) => {
    return new Date(dateString).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  };

  // Get reports for a specific date
  const getReportsForDate = (date) => {
    return savedReports.filter(r => r.reportDate === date);
  };

  // Check if reports exist for selected date
  const hasReportsForDate = getReportsForDate(reportDate).length > 0;

  if (loading) {
    return <div className="reports-loading">Loading reports...</div>;
  }

  return (
    <div className="reports-container">
      <div className="reports-header">
        <h1>Security Reports</h1>
        <p>Generate comprehensive security reports and compliance documentation</p>
      </div>

      {/* Auto-save Status */}
      {autoSaveStatus && (
        <div className="auto-save-status">
          <FaClock /> {autoSaveStatus}
        </div>
      )}

      {/* Report Date Selector */}
      <div className="report-date-selector">
        <label htmlFor="reportDate">Report Date:</label>
        <input
          type="date"
          id="reportDate"
          value={reportDate}
          onChange={(e) => setReportDate(e.target.value)}
          className="date-input"
        />
        <button 
          className="btn btn-secondary"
          onClick={() => setShowHistory(!showHistory)}
        >
          <FaHistory /> {showHistory ? 'Hide History' : 'View History'}
        </button>
        {hasReportsForDate && (
          <div className="date-status">
            <span className="status-indicator">✓ Reports available for {reportDate}</span>
          </div>
        )}
      </div>

      {/* Report History */}
      {showHistory && (
        <div className="report-history">
          <h2>Report History</h2>
          {savedReports.length === 0 ? (
            <p className="no-history">No saved reports found.</p>
          ) : (
            <div className="history-grid">
              {savedReports.map((savedReport) => (
                <div key={savedReport.id} className="history-card">
                  <div className="history-header">
                    <h3>{savedReport.title}</h3>
                    <div className="history-badges">
                      {savedReport.autoGenerated && (
                        <span className="badge auto-generated">Auto</span>
                      )}
                      <button 
                        className="btn-delete"
                        onClick={() => deleteSavedReport(savedReport.id)}
                        title="Delete Report"
                      >
                        ×
                      </button>
                    </div>
                  </div>
                  <div className="history-meta">
                    <p><strong>Generated:</strong> {formatDate(savedReport.generatedDate)}</p>
                    <p><strong>Report Date:</strong> {formatDate(savedReport.reportDate)}</p>
                    <p><strong>Alerts:</strong> {savedReport.metrics.totalAlerts}</p>
                    <p><strong>Critical:</strong> {savedReport.metrics.criticalAlerts}</p>
                  </div>
                  <div className="history-actions">
                    <button 
                      className="btn btn-primary"
                      onClick={() => setSelectedHistoryReport(savedReport)}
                    >
                      <FaEye /> View Report
                    </button>
                    <button 
                      className="btn btn-secondary"
                      onClick={() => {
                        const content = JSON.stringify(savedReport.data, null, 2);
                        const blob = new Blob([content], { type: 'application/json' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `${savedReport.title.toLowerCase().replace(/\s+/g, '_')}_${savedReport.reportDate}.json`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                      }}
                    >
                      <FaDownload /> Download
                    </button>
                  </div>
                </div>
              ))}
            </div>
          )}
        </div>
      )}

      {/* Report Metrics Overview */}
      <div className="reports-overview">
        <div className="overview-card">
          <FaShieldAlt className="overview-icon" />
          <div className="overview-content">
            <h3>Total Alerts</h3>
            <div className="overview-value">{reportMetrics.totalAlerts}</div>
          </div>
        </div>
        <div className="overview-card critical">
          <FaExclamationTriangle className="overview-icon" />
          <div className="overview-content">
            <h3>Critical Threats</h3>
            <div className="overview-value">{reportMetrics.criticalAlerts}</div>
          </div>
        </div>
        <div className="overview-card">
          <FaGlobe className="overview-icon" />
          <div className="overview-content">
            <h3>Countries Affected</h3>
            <div className="overview-value">{reportMetrics.uniqueCountries}</div>
          </div>
        </div>
        <div className="overview-card">
          <FaServer className="overview-icon" />
          <div className="overview-content">
            <h3>Unique IPs</h3>
            <div className="overview-value">{reportMetrics.uniqueIPs}</div>
          </div>
        </div>
      </div>

      {/* Available Reports */}
      <div className="reports-grid">
        {reports.map((report) => {
          const existingReport = getReportsForDate(reportDate).find(r => r.type === report.id);
          
          return (
            <div key={report.id} className="report-card">
              <div className="report-header">
                <div className="report-icon">{report.icon}</div>
                <div className="report-info">
                  <h3>{report.title}</h3>
                  <p>{report.description}</p>
                  {existingReport && (
                    <p className="report-status">
                      ✓ Available for {reportDate} 
                      {existingReport.autoGenerated && ' (Auto-generated)'}
                    </p>
                  )}
                </div>
              </div>
              <div className="report-actions">
                <button 
                  className="btn btn-primary"
                  onClick={() => handleGenerateReport(report)}
                >
                  <FaEye /> Generate Report
                </button>
                {!existingReport && (
                  <button 
                    className="btn btn-secondary"
                    onClick={() => handleSaveReport(report)}
                  >
                    <FaSave /> Save for {reportDate}
                  </button>
                )}
                <button 
                  className="btn btn-secondary"
                  onClick={() => handleDownloadReport(report)}
                >
                  <FaDownload /> Download
                </button>
              </div>
            </div>
          );
        })}
      </div>

      {/* Report Preview */}
      {selectedReport && (
        <div className="report-preview">
          <div className="preview-header">
            <h2>{selectedReport.data.title}</h2>
            <button 
              className="btn btn-close"
              onClick={() => setSelectedReport(null)}
            >
              ×
            </button>
          </div>
          <div className="preview-content">
            <div className="preview-section">
              <h3>Report Summary</h3>
              <p>{selectedReport.data.summary || selectedReport.data.date}</p>
            </div>
            
            {selectedReport.data.keyFindings && (
              <div className="preview-section">
                <h3>Key Findings</h3>
                <ul>
                  {selectedReport.data.keyFindings.map((finding, index) => (
                    <li key={index}>{finding}</li>
                  ))}
                </ul>
              </div>
            )}

            {selectedReport.data.recommendations && (
              <div className="preview-section">
                <h3>Recommendations</h3>
                <ul>
                  {selectedReport.data.recommendations.map((rec, index) => (
                    <li key={index}>{rec}</li>
                  ))}
                </ul>
              </div>
            )}

            {selectedReport.data.threatBreakdown && (
              <div className="preview-section">
                <h3>Threat Breakdown</h3>
                <div className="threat-breakdown">
                  {selectedReport.data.threatBreakdown.map((threat, index) => (
                    <div key={index} className="threat-item">
                      <span className="threat-type">{threat.type}</span>
                      <span className="threat-count">{threat.count} ({threat.percentage}%)</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      )}

      {/* Historical Report Preview */}
      {selectedHistoryReport && (
        <div className="report-preview">
          <div className="preview-header">
            <h2>{selectedHistoryReport.title} (Historical)</h2>
            <button 
              className="btn btn-close"
              onClick={() => setSelectedHistoryReport(null)}
            >
              ×
            </button>
          </div>
          <div className="preview-content">
            <div className="preview-section">
              <h3>Report Information</h3>
              <p><strong>Generated:</strong> {formatDate(selectedHistoryReport.generatedDate)}</p>
              <p><strong>Report Date:</strong> {formatDate(selectedHistoryReport.reportDate)}</p>
              <p><strong>Total Alerts:</strong> {selectedHistoryReport.metrics.totalAlerts}</p>
              <p><strong>Critical Alerts:</strong> {selectedHistoryReport.metrics.criticalAlerts}</p>
              {selectedHistoryReport.autoGenerated && (
                <p><strong>Type:</strong> Auto-generated</p>
              )}
            </div>
            
            <div className="preview-section">
              <h3>Report Summary</h3>
              <p>{selectedHistoryReport.data.summary || selectedHistoryReport.data.date}</p>
            </div>
            
            {selectedHistoryReport.data.keyFindings && (
              <div className="preview-section">
                <h3>Key Findings</h3>
                <ul>
                  {selectedHistoryReport.data.keyFindings.map((finding, index) => (
                    <li key={index}>{finding}</li>
                  ))}
                </ul>
              </div>
            )}

            {selectedHistoryReport.data.recommendations && (
              <div className="preview-section">
                <h3>Recommendations</h3>
                <ul>
                  {selectedHistoryReport.data.recommendations.map((rec, index) => (
                    <li key={index}>{rec}</li>
                  ))}
                </ul>
              </div>
            )}

            {selectedHistoryReport.data.threatBreakdown && (
              <div className="preview-section">
                <h3>Threat Breakdown</h3>
                <div className="threat-breakdown">
                  {selectedHistoryReport.data.threatBreakdown.map((threat, index) => (
                    <div key={index} className="threat-item">
                      <span className="threat-type">{threat.type}</span>
                      <span className="threat-count">{threat.count} ({threat.percentage}%)</span>
                    </div>
                  ))}
                </div>
              </div>
            )}
          </div>
        </div>
      )}
    </div>
  );
};

export default Reports; 